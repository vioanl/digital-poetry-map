// MEMORY OF VOICES (VIVID LIME LINE)
// Processing (Java mode)

int N = 15000; 
PVector[] p = new PVector[N];
PVector[] v = new PVector[N];
float[] anchorX = new float[N]; // Remembers where each particle belongs on the line
float t = 0;             

void setup() {
  size(800, 800, P3D);
  smooth(8);
  background(255);       
  
  // Initialize particles in a straight horizontal line
  float lineLength = width * 0.8;
  
  for (int i = 0; i < N; i++) {
    // Distribute evenly across the X axis
    float x = map(i, 0, N, -lineLength/2, lineLength/2);
    
    // Add a tiny bit of random spread so it's not a perfect razor line initially
    p[i] = new PVector(x, random(-2, 2), random(-2, 2));
    anchorX[i] = x; // Store original X position to tether them
    v[i] = new PVector();
  }
}

void draw() {
  // --- AESTHETIC MATCHING ---
  blendMode(BLEND); 
  
  noStroke();
  // We use a slightly faster fade (60) because voices are twitchy
  fill(255, 60); 
  rect(0, 0, width, height);
  
  translate(width/2, height/2);
  
  // No rotation for Voices - we want to see the waveform clearly
  // But we can rotate slightly if mouse moves to see the 3D depth
  // rotateY(map(mouseX, 0, width, -0.5, 0.5)); 
  
  t += 0.04; // Very fast time cycle for "jittery" voice movement
  
  for (int i = 0; i < N; i++) {
    
    // 1. CALCULATE FLOW (The Voice Data)
    PVector f = voiceFlow(p[i], t);
    v[i].add(f);
    
    // 2. CONSTRAIN TO LINE (The "Memory" Structure)
    // Pull particle back to its anchor X position (weak pull)
    float springX = (anchorX[i] - p[i].x) * 0.05;
    // Pull particle back to Y=0 (center line) but very weakly, allowing vibration
    float springY = -p[i].y * 0.01; 
    // Pull particle back to Z=0 (keep it flat-ish)
    float springZ = -p[i].z * 0.05;
    
    PVector gravity = new PVector(springX, springY, springZ);
    v[i].add(gravity);
    
    // 3. PHYSICS UPDATE
    // Higher friction (0.6) than Wind because voices are sharp/staccato
    v[i].mult(0.6);      
    p[i].add(v[i]);
    
    // --- COLOR ---
    // Vivid Lime Green. 
    // We use (30, 200, 30) instead of pure (0,255,0) so it's visible on White.
    // Alpha is low (50) to create a glowing effect where particles cluster.
    stroke(30, 200, 30, 50);      
    point(p[i].x, p[i].y, p[i].z);
  }
}

// --- HELPERS -------------------------------------------------------------

PVector voiceFlow(PVector pos, float tt) {
  // Scale of the noise texture
  float s = 0.005;        
  
  // We want the noise to mostly affect the Y axis (Height/Volume)
  // The 'pos.x' is used to create the wave shape along the line
  
  // Amplitude varies over time (loudness of the voice)
  float amplitude = (noise(tt * 0.5) * 500) + 50; 
  
  // Create a "Wave" force
  float ny = noise(pos.x * s + tt, tt) - 0.5;
  
  // Create some "Grit" (Z axis jitter)
  float nz = noise(pos.x * 0.1, tt * 2) - 0.5;
  
  // The flow pushes wildly up/down, but hardly left/right
  return new PVector(0, ny * amplitude, nz * 50); 
}

void keyPressed() {
  if (key == 's' || key == 'S') {
    saveFrame("voices-####.png");
  }
}
